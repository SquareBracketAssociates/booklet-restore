!! Storing Objects Manually

As we saw in the previous chapter, when a transaction is active (following a beginTransaction) ReStore will track changes to persistent objects and add those objects to the active transaction. All changes are then committed (or rolled back) in a single step. 

This automatic tracking of changes means that no special actions are required to mark an object as changed, and so your application does not need to consider which objects it is likely to change. Thus fully persistent applications are quick and easy to construct.
 
In some circumstances however you may want to take more control of the updating of your persistent objects. One scenario where this is desirable is where you prefer to structure your application as a number of mode-less screens. By mode-less, we mean that the user is free to switch between different screens at will, as opposed to modal screens, which restrict the user to working on one screen at once.

If each mode-less screen has its own ‘Save’ or ‘Apply Changes’ button then the single transaction model is not appropriate - sending commitTransaction will commit all changes made, regardless of from which screen they originated. 

What is required is for each screen to manually notify ReStore of which objects it has changed (or is likely to have changed). This chapter discusses the mechanisms ReStore provides to accomplish this.

 
!!! Storing an Object
ReStore allows you to explicitly ask an object to store itself (if not yet persistent) or to store any changes made to itself (if already persistent) by simply sending it the message ==store==.

This effectively begins a transaction, adds the receiver object to the transaction, and then finally commits the transaction. Thus the following examples are equivalent:

[[[
"Storing a new object - with transaction:"
ReStore evaluateAsTransaction: 
[(Customer new firstName: 'John'; surname: 'Smith'; yourself) store]. 

"Storing a new object - without transaction:"
(Customer new firstName: 'John'; surname: 'Smith'; yourself) store.

"Updating an existing object - with transaction:"
ReStore evaluateAsTransaction: [johnSmith middleName: 'David'.]. 

"Updating an existing object - without transaction:"
johnSmith middleName: 'David'; store.
]]]


Note that the same rules on the automatic storing of referenced non-persistent objects apply here as when using transactions.

!!!! unstore
Similar to ==store==, you may send ==unstore== to explicitly an object to ask it to delete itself from the database.

[[[
"Deleting an object - with transaction:"
ReStore evaluateAsTransaction: [johnSmith unstore]. 

"Deleting an object - without transaction:"
johnSmith unstore.
]]]


Again, the rules on the automatic ==unstore== of dependent objects apply.


Note that ==store== and ==unstore== are the same messages that are used to tell ReStore to persist new objects and delete existing objects within a transaction (see 3.1 and 3.4). In the transaction use-case they do not take effect immediately but add their change to the current transaction, whereas in the non-transaction use-case they act immediately. 
Thus their behaviour changes depending on whether they are used whilst a transaction is active or not. 


!!! Rollback and Refresh
Similar to when working with transactions you may rollback any changes made to a persistent object; this is done by simply sending it the message ==rollback==

[[[
johnSmith rollback	
]]]

This will revert the object to its state prior to the changes being made. Similar to ==rollbackTransaction== you can use this to implement an easy “Undo” or “Cancel Changes” function.

!!!! Object Refresh
rollback only reverts the object back to its previous state within the current image. 

In a multi-user scenario it is also possible that another user may have changed the object within the database. If you wish to bring the object up-to-date with its current state in the database you can send it the message ==refresh==

[[[
johnSmith refresh	
]]]

Note that ==refresh== effectively performs a rollback for objects which have not been updated in the database (compared to your image).

If your application has multiple concurrent users you may wish to use ==refresh== prior to displaying an object to ensure the user sees the latest version.


 
!!! Checking for Changes
When working with persistent objects it can be useful to know whether the user has made any changes compared to the version of the object originally fetched from the database. For example you may want to selectively enable an “Apply Changes” button depending on whether any changes have actually been made.

You could track when a change is made in your own code, but ReStore enables you to do this automatically by asking a persistent object if it ==hasChanged==. Example:

[[[
johnSmith hasChanged. "false"

johnSmith middleName: 'David'.
johnSmith hasChanged. "true"

johnSmith store.
johnSmith hasChanged. "false"
]]]

Note that ==hasChanged== only compares the current state of the object to the last version fetched from or stored in the database by your image. It does not compare it with the current version in the database, where it may have been updated by another user.
 
!!! Dependent Objects
A complication with the manual way of managing changes (when compared to using transactions) is tracking all objects that may be changed by a particular area of code. As an extreme example let’s consider an application where a customer can edit any of their own details plus their active orders. Thus we have the following potentially changed objects:

- a ==Customer==
- their ==address== object
- their ==customerOrders== collection
- each element of their ==customerOrders== collection
- each ==CustomerOrder==’s ==items== collection
- each element of each ==CustomerOrder==’s items collection

As you can see this quickly becomes a complicated set of objects to keep track of. Fortunately ReStore can help avoid the need for your code to explicitly store each of these objects by using information from the objects’ reStoreDefinition.

In Section 2.7 we considered the concept of dependent relationships between objects and stated that one advantage of defining these is that dependents of an object are automatically deleted from the database when no longer referenced from that object. A further advantage is that dependent objects are also stored when their owning object is stored. So, assuming ==Customer== is defined as follows:

[[[
define: #address as: Address dependent;
define: #customerOrders as: (OrderedCollection of: CustomerOrder dependent owner: #customer);
]]]

… and if ==CustomerOrder== is defined:

[[[
define: #items as: (OrderedCollection of: CustomerOrderItem dependent owner: #customer);
]]]

This gives us a hierarchy of dependent relationships that can be visualized as follows (shown in Figure *@hierarchy*):


+>figures/hierarchy.png|label=hierarchy+
 
With the dependent relationships defined in this way, the application only needs to send ==store== to the ==Customer== object for any changes to all of its dependent objects (and their dependents, recursively) to be stored in the database.

Additionally, the other messages discussed in this chapter (==refresh==, ==rollback==, ==hasChanged==) also apply to dependent objects in the same way as store, giving the same simplicity advantages.


!!! Working with Multiple Objects
The examples so far in this chapter have all involved working with individual objects (potentially with their set of dependent objects). 

Depending on your application you may want to send store, refresh etc. to a collection of objects at once. You could repeatedly send store to each object in turn, though in addition to being long-winded this will create an individual transaction for each invocation of store. If one of these transactions fails this could potentially leave your database in an inconsistent state, with some changes committed and others not.

Fortunately all the messages discussed in this chapter have variants that enable you to work with collections of objects; this wraps each operation in a single overall transaction which will either succeed or fail in its entirety. These messages are defined in Collection and are the same as the messages for individual objects, appended with ""All"":

- ==storeAll==
- ==unstoreAll==
- ==rollbackAll==
- ==refreshAll==

You may also check if any member of a collection has been changed:

- ==hasAnyChanged==

To use these, simply assemble a collection of the objects you are working with then send the appropriate message:

[[[
(Array with: customer1 with: customer2 with: customer3) storeAll.
]]]


 

