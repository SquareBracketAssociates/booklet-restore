!! Working with multiple ReStores

So far in this manual we have used the singleton default instance of ==SSWReStore==, accessed via the ReStore global variable. This is a simple and convenient way of using ReStore where only one ReStore instance per image is necessary. 

It is equally possible to use multiple instances of ==SSWReStore==, for example in a web application server you may choose to have one ==SSWReStore== instance per user connection.

Each instance of ==SSWReStore== is completely independent and shares no objects or state with another instance. This allows you to have an active transaction in one instance but not another, instances connected to different databases, or instances connected to the same database but with different user credentials (e.g. separate user and admin instances) for added security. 


!!! Manually Specifying a ReStore 
At its simplest you can just create your own instance of ==SSWReStore==:

[[[
myReStore := SSWReStore new
]]]

Once created and connected you may pass your own ==SSWReStore== instance as a parameter to ReStore messages which normally assume the default singleton instance; this will cause your instance to be used instead:

[[[
"Storing a new object in default ReStore"
Customer new store. 
]]]

[[[
"Storing a new object in myReStore"
Customer new storeIn: myReStore.  
]]]

[[[
"Storing multiple new objects in default ReStore"
aCollection storeAll. 
]]]

[[[
"Storing multiple new objects in myReStore"
aCollection storeAllIn: myReStore. 
]]]

[[[
"Accessing stored instances in default ReStore"
Customer storedInstances.
]]]

[[[
"Accessing stored instances in myReStore"
Customer storedInstancesIn: myReStore.
]]]

[[[
"Accessing similar instances in default ReStore"
templateObject similarInstances.
]]]

[[[
"Accessing similar instances in myReStore"
templateObject similarInstancesIn: myReStore.
]]]

!!! Using Affinity
In addition to specifying the SSWReStore instance manually, ReStore also provides a way for the “current” or “active” ReStore to be selected automatically. This is done by defining the ""affinity"" of a particular ReStore instance.

!!!! Process Affinity
A simple example of this is process affinity - having a separate ==SSWReStore== instance for a particular process. ReStore provides a straightforward way to configure this: 

[[[
aProcess reStore: myReStore. 
]]]


With this defined, myReStore will be used in place of the default singleton ReStore whenever aProcess is active. Thus you may use store, ==storeAll== and ==storedInstances== as normal without specifying ==myReStore== as a parameter. 

If you wish to access the currently-active instance of ==SSWReStore== (e.g. to begin a transaction) you can do so as follows:

[[[
SSWReStore default
]]]

You may remove a process affinity as follows:

[[[
aProcess reStore: nil. 
]]]

!!!! General Affinity
Process affinity is a special case of general affinity - the ability to specify a particular ==SSWReStore== instance for an arbitrary “current state” of your image. For example, under a web application framework you may have a dynamic variable named ==CurrentSession== defining the active session when handling a request. You can bind a particular ==SSWReStore== instance to a particular session as follows:

[[[
myReStore 
	affiliateWith: aSession
	using: [ :session | CurrentSession value == session]. 
]]]

With this affinity defined, ==myReStore== will be used in place of the default singleton ReStore whenever ==aSession== is the active value of ==CurrrentSession==. Again, this means you may use ==store==, ==storeAll== and ==storedInstances== as normal without specifying ==myReStore== as a parameter, and you may access the currently-active ReStore instance via ==SSWReStore default==.

You may remove a general affinity as follows:

[[[
myReStore disaffiliateWith: aSession
]]]

