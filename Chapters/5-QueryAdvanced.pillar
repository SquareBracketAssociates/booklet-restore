!! Advanced Querying

This chapter continues discussing querying in ReStore, with an emphasis on more advanced topics and techniques.


!!! Refining a Query
Sometimes you may wish to progressively refine a storedInstances collection without actually requiring the member objects of that collection to be in memory. This may be due to the structure of your user interface, or possibly to avoid one large enumeration block containing many separate conditions logically ANDed together. Refining a query in this way can be done easily and efficiently using the method ==satisfying:==

==satisfying:== performs in a similar way to select:. However, instead of returning a real collection of objects matching the discriminator block (which would entail fetching all those objects from the database) satisfying: returns another storedInstances  collection. You may then ==select:==, ==reject:== etc. against this block, query its ==size== or ==isEmpty== etc., or alternatively refine the collection further with further ==satisfying:== messages. 


!!!! Example:

[[[
allSmiths := Customer storedInstances satisfying: [ :each | each surname = 'Smith'].
allJohnSmiths := allSmiths satisfying: [ :each | each firstName = 'John'].
specificJohnSmith := allJohnSmiths detect: [ :each | each dateOfBirth = aDate]
]]]


The important point to grasp is that no objects are fetched from the database when using ==satisfying:== – this makes it very efficient. In the above example, if ==select:== were used instead of ==satisfying:== possibly several thousand ==Customer== instances would have been fetched from the database by the surname part of the query. Most of these would be discarded as the query was refined – this would make the whole process very inefficient. By instead using ==satisfying:== there is no interaction with the database until the final ==detect:==.


!!!! withoutInheritance

It was noted in section 2.9 that hierarchies of classes which share a single table allow queries against a superclass to also return instances of subclasses. Sometimes this is not the desired effect; in this case a new ==storedInstances== collection, specifically excluding the subclasses, can be obtained by using the message ==withoutInheritance==. 

As an example, consider a hierarchy representing printers and combined printer/scanners:

[[[
Printer	 	- printSize, printResolution
	PrinterScanner	- scanSize, scanResolution
]]]

The query:
[[[
Printer storedInstances select: [ :each | each printSize = 'A4'].
]]]
… would return both ==Printers== and ==PrinterScanners== with A4 print size. If only Printer instances are required this can be achieved by specifying ==withoutInheritance==:

[[[
Printer storedInstances withoutInheritance select: [ :each | each printSize = 'A4'].
]]]

!!! Expanding a Query
Sometimes it may be convenient or necessary to expand an storedInstances collection to encompass more elements. Again, this can be due to the structure of a user interface, or to avoid a single enumeration block with multiple conditions logically ORed together.
This can be accomplished easily by 'adding' together storedInstances collections using the standard Smalltalk addition method addAll:. For example, to find all Customers named 'Smith' or 'Jones': 

[[[
allSmithsOrJones := Customer storedInstances satisfying: [ :each | each surname = 'Smith'].
allSmithsOrJones addAll: (Customer storedInstances satisfying: [ :each | each surname = 'Jones']).
]]]

There are a couple of points to note with the use of ==addAll:==. Firstly the message behaves like a regular Collection addition method in that it returns the message argument, not the receiver. Secondly, you may only add together ==storedInstances== collections based on the same model class (or an inherited class sharing the same table). 
 
!!! Incremental fetch with ReadStreams
In section 5.4 we noted that using ==asOrderedCollection== to fetch all elements of a large collection should be used with caution due to speed and memory considerations. 

One way to mitigate this is by fetching a few elements at a time – for example a user interface may display a page with the first 50 members of a collection, and provide a “Next” button to fetch the next 50 elements (and then the next 50, and so on). 

ReStore allows you to implement this style of behavior easily using normal Smalltalk ReadStream semantics by asking any storedInstances collection for its readStream

[[[
Customer storedInstances readStream

(Customer storedInstances satisfying: [ :each | each surname = 'Smith']) readStream
]]]

Once you have obtained a stream onto the collection you may then incrementally fetch elements of the collection using standard ==ReadStream== messages (==next==, ==next:==, ==upTo:== etc.). Since only the data for the requested elements is fetched from the database, good performance can be maintained even for very large collections. 

Note that the ability to fetch data incrementally is dependent on support from the underlying database interface. At the time of writing incremental fetch is supported by ODBC for Dolphin and SQLite and MySQL for Pharo. The Pharo P3 PostgreSQL interface currently always fetches all matching results, though you may still stream over these and ReStore will not reify the data into objects until needed. 

 
!!! Reporting with ==collect:==
In addition to the enumeration messages discussed in the previous chapter (select:, detect: etc.), you can also use collect: with a storedInstances collection. In this case the enumeration block is used to fetch individual items of data from the database - this allows you to construct simple reports on your stored data. For example, the following block:

[[[
Customer storedInstances collect: [ :each | each surname]
]]]

…will fetch the surnames of all Customers, without fetching the Customer objects themselves. 

Obviously one isolated item of data is not much use on its own, so ReStore allows you to fetch multiple items in a single query via the use of a new binary operator: || (double vertical bar). This concatenates together each item of data, returning the result as an Array. Using this technique it is possible to expand the above example to something more useful:

[[[
Customer storedInstances collect: [ :each | each firstName || each surname || each dateOfBirth]
]]]

The block argument to collect: is subject to the same rules as with the other enumeration messages. This means it is also possible to use messages defined by the class (where they satisfy the rules for query blocks) and to perform simple transformations on the server using supported message-to-function transformations:

[[[
Customer storedInstances collect: [ :each | each fullName || each dateOfBirth year]
]]]

!!!! Refining the report
Since the receiver of collect: is a storedInstances collection you are able to use the satisfying: message to perform the collect: query over a subset of your data, for example:

[[[
allCustomers := Customer storedInstances
ukCustomers := allCustomers satisfying: [ :each | each address country = 'United Kingdom'].
ukCustomers collect: [ :each | each fullName || each dateOfBirth year]

allOrders := CustomerOrder storedInstances.
recentOrders := allOrders satisfying: [ :each | each orderDate year = Date today year].
recentOrders collect: [ :each | each customer fullName || each totalPrice]
]]]

 
!!! Aggregate Queries
Relational databases support aggregate queries, allowing calculations to be performed on groups of data, typically returning totals, counts and other numeric functions. ReStore allows you to create such queries from a storedInstances collection via the new enumeration message ==project:== and the messages ==count==, ==sum==, ==average==, ==minimum== and ==maximum==:

[[[
"Number of recent orders by customer"
recentOrders project: [ :each | each customer customerNo || each count].

"Total recent order value by customer"
recentOrders project: [ :each | each customer customerNo || each totalPrice sum].
]]]

Aggregate messages can also be combined in a single query, for example:

[[[
recentOrders project: 
[ :each | 
each customer customerNo || each count || each totalPrice sum || 
each totalPrice average || each totalPrice minimum || each totalPrice maximum]
]]]

Using ==project:== and ==aggregate== messages allows your application to quickly produce summary reports with all calculation done on the server and the minimum of data transferred. Thus they can be very quick.

!!!! Grouping
Within a ==collect:== block, any element not subject to an aggregate message is used to group the results. In the above examples we used each customer’s unique customerNo to group results by individual customers. If instead we had used each customer’s name:

[[[
recentOrders project: [ :each | each customer fullName || each count]
]]]

…then any customers with the same name would have had their order statistics grouped together into a single result – almost certainly not what you want for this particular report. 

You can avoid this by additionally including the unique ID of the object why by which you wish to group the results:

[[[
recentOrders project: [ :each | each customer customerNo || each customer fullName || each count]
]]]

Note this is possible even where the unique ID is not defined as one of the object’s own instance variables, by using the special message ==\_id==. For example if we didn’t maintain a customer number as part of the Customer object, the above example could be written: 

[[[
recentOrders project: [ :each | each customer _id || each customer fullName || each count]
]]]

!!! Additional Functions

In “Messages and Functions” (Section 5.2) it was mentioned that within query blocks it is possible to use certain Smalltalk messages that can be mapped to equivalent SQL functions. For example the String message asUppercase is mapped to the SQL function UPPER().  

ReStore provides a default set of such translations however it is possible to specify additional translations depending on your requirements and the functions supported by your chosen database. By creating additional translations you can transfer more of the querying effort to the database, increasing the performance of your application.

As an example we will look at adding the SQLite function RTRIM(). When used with a single String argument the function removes any spaces from the right-hand side of the String (i.e. removes any trailing spaces) - this is roughly equivalent to the Pharo String method trimRight.

We can add a translation between the message trimRight and the function RTRIM() to a connected ReStore instance as follows:

[[[
ReStore translateMessage: #trimRight toFunction: 'RTRIM(%1)' asSQLFunction
]]]

With this translation added you can now use the message in query blocks, for example:

[[[
Customer storedInstances collect: [ :each | each fullName trimRight]
Customer storedInstances select: [ :each | each fullName trimRight = ‘John Smith’]
]]]

!!!! Notes:
# Function translations are held by the sqlDialect object of ReStore which is created and reinitialized each time ReStore connects, based on the type of database. Therefore you should add your custom function translations to ReStore only after connecting, and re-add them if you subsequently disconnect and reconnect
# Parameters within the SQL function are represented by numbered placeholders %1, %2 etc.. The first parameter %1 refers to the receiver of the message whilst additional parameters correspond to the arguments of the message – so function parameter %2 corresponds to the first message argument, %3 to the second etc.
# The method trimRight does not actually exist in Dolphin Smalltalk, however you can still add the translation since the method itself is not actually evaluated (though browsers will give an “undefined selector” warning)
# The translated SQL does not have to be a single function but can be any valid SQL expression. Let’s say you have added a method plusPercent: as an extension to Number and would like to use an equivalent to this in a query block. You can do this by adding a translation from plusPercent: to an equivalent calculation in SQL:

[[[
ReStore 
	translateMessage: #plusPercent: 
	toFunction: '%1 * (1 + (%2 / 100))' asSQLFunction 
]]]

!!!! Specifying the Result Type
With message-function translations there is an implicit assumption that the result of the function is of the same type as the receiver. Whilst this assumption holds in many cases –numerical functions (+, - etc.), String concatenation, and the examples discussed above – this is not always the case. For example, the String message size is mapped to the SQL function LEN() (or some variant depending on the database) whose result is an Integer, not a String. In cases like this ReStore allows you to explicitly state the class of the result object.

As an example we will consider a further extension method to Number asPercentageString which displays a floating point number in the range 0-1 as a percentage String, e.g. '50\%'. When creating a translation to a matching SQL expression we must specify the class of the result as String, since it does not match the receiver class of Number:

[[[
	ReStore
		translateMessage: #asPercentageString 
		toFunction: ('CAST((%1*100) as char) || "%%"' asSQLFunctionWithResultClass: String)
]]]
	
!!!! Notes:
# This SQL expression is specific to SQLite; it will differ for other databases. For example in MySQL it would be 'CONCAT(CAST((\%1*100) as char), "%%")'
# Note the doubled percent sign "%%" at the end of the expression – this is needed to escape the percent sign since it is a feature of the numbered parameter placeholders
# ReStore provides a number of convenience methods to declare functions similar to this more succinctly: asSQLFunctionStringResult, asSQLFunctionIntegerResult and asSQLFunctionBooleanResult

!!!! Result Type based on Argument Type
There is a further possibility when translating a function – the result type may vary based on the argument type. As an example consider a Number method ==ifPositive:ifNegative:== which returns either the first or second argument depending on the sign of the receiver, e.g.

[[[
	123 ifPositive: 1 ifNegative: -1
	-123 ifPositive: 'POS' ifNegative: 'NEG'
]]]

This can be translated to SQL using the CASE function available in most databases, however we need to declare that the result type will be neither the receiver class or a fixed class, but the class of one of the arguments (we assume that all arguments and thus possible results are of the same class). This can be done as follows:

[[[
	ReStore 
		translateMessage: #ifPositive:ifNegative: 
		toFunction: ('CASE WHEN %1>=0 THEN %2 ELSE %3 END' asSQLFunction resultParamIndex: 2)
]]]

By adding ==resultParamIndex: 2== to the declaration we state the result of the function will be the same type as parameter \%2.  


!!! Data-Modifying Queries
In addition to returning objects, storedInstances collections can also be used to modify data within the database.

""modify:""
==modify:== is a type of enumeration message where the argument block is expected to update some aspect of the member objects. However it is important to understand that the update is done directly within the database – this makes the update very efficient (since no objects are fetched from the database) but has the limitation that any objects already in memory (either in your image, or that of another user) will not be updated. Thus modify: is most suitable for 'supervisor'−type activities, ideally when no other image is connected to the database. 

As an example of its use, let's say that you've just added the instance variable country to the class Address, in preparation for handling overseas customers. All current addresses are presumed to be in your home country; you wish to update these to make this explicit. This is an ideal application for modify: 

[[[
Customer storedInstances modify: [ :each | each address country: 'United Kingdom'].
]]]

""unstoreAll / unstore: ""
==unstoreAll== can be used to quickly delete from the database all members of a storedInstances collection. For example, the following would delete all ==CustomerOrder== objects from the database:

[[[
	CustomerOrder storedInstances unstoreAll
]]]

""unstore:"" operates in a similar way, but takes as its parameter a select:-style block which restricts the objects to delete. The following would delete all ==CustomerOrder==s placed before 2015:

[[[
	CustomerOrder storedInstances unstore: [ :each | each orderDate year < 2015]
]]]

!!! Performance Considerations

At the start of the previous chapter we mentioned that, after reading an object from the database with an initial query, you may traverse the object’s links to other objects; these are then automatically fetched from the database. Depending on the structure of your application this can lead to a potential performance issue known as the “1\+N problem”. 

Consider a screen that allows you to find multiple Customer instances based on certain criteria. The results list of this screen shows the details of each matching customer (name etc.) plus the number of CustomerOrders placed by that customer.

Fetching the list of matching customers can be done with a single  query. However as each customer’s details are displayed the collection of orders for that customer will be fetched from the database in order to display its size. Thus we have one query returning N customers, then N queries to fetch each customer’s orders. 

You can avoid this performance penalty by preconfiguring a storedInstances collection to fetch any related object or collection of objects for every member of the ==storedInstances== collection using a single query. This is done via the messages ==include:== and ==includeAll:==

[[[
template := Customer new.
template surname: 'Sm*' asWildcard.
matchingCustomers := template similarInstances.
matchingCustomers include: #customerOrders.
matchingCustomers := matchingCustomers asSortedCollection.
]]]

Now, when ==asSortedCollection== is used to fetch the matching customers, one additional query will automatically be issued to fetch the customerOrders of all matching customers.

==include[All]:== can also be used to fetch single related objects as well as collections. For example, if your results list also needed information from the address instance variable of a Customer, you would add this to the list of instance variables to be fetched:

[[[
matchingCustomers includeAll: #(#customerOrders #address).
]]]

!!!! With Real Collections

An alternative scenario that can also be affected by the 1\+N problem is where you already have a real collection of objects in your image, but you want to fetch the contents of certain instance variables for all members of that collection.

Let’s twist our current example of a “Find Customer” screen to demonstrate this. Let’s say that the initial list of customers only displays information directly held in the Customer object. Thus at this stage we have no need to user includeAll: to fetch additional objects – let’s remove this from our previous code:

[[[
template := Customer new.
template surname: 'Sm*' asWildcard.
matchingCustomers := template similarInstances asSortedCollection.
]]]

However, once the user has located the customers of interest they can then click a “Details” button to display additional information for the matching customers – again, let’s say this will be based on their orders and address. By allowing this information to be fetched in the standard way (transparently, on demand) we would incur two queries for each Customer (one for the address, one for the customerOrders). However we can avoid this by instructing the (real) SortedCollection to fetch this information for all its elements using fetchAll: (or fetch: for a single instance variable):

[[[
matchingCustomers fetchAll: #(#customerOrders #address).
]]]

Now, similar to a ==storedInstances ==collection and ==includeAll:==, the real collection will issue a single query for each requested instance variable, fetching the contents of those variables for all members of the collection.

By careful use of ==include[All]:== and ==fetch[All]:== you can avoid the 1\+N problem from impacting the performance of your application.
 
