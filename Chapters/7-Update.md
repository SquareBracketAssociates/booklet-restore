## Update ClashesWhere an application is the sole user of a database, transactions should always succeed. However where more than one user is interacting with the database there is the possibility for an update clash. Consider the following example:| Time | User A | User B | Database |  || 00:00 | Begin editing Person 'John Smith' |  | 'John Smith' |  || 00:01 |  | Begin editing Person 'John Smith' | 'John Smith' |  || 00:09 | Change _surname_ to **'Smythe'** |  | 'John Smith' |  || 00:10 |  | Change surname to 'Smithe' | 'John Smith' |  || 00:14 | commitTransaction / store |  | 'John **Smythe**' |  || 00:15 |  | commitTransaction / store | ??? |  |What should happen when User B commits their change? If the change is allowed to succeed, then User A's changes will be overwritten.If it fails, then User B will potentially lose their changes -- is this acceptable?By default ReStore records a version number for each object in the database; each time the object is updated the version is incremented by 1.This allows ReStore to detect where another database user has changed an object, and thus to avoid overwriting another user’s changes from being overwritten.Where this happens, the originating `commitTransaction` or `store` message will fail - this chapter discusses how to handle this. ### Handling Transaction FailuresWhen working with transactions the result of an update clash is that the transaction will fail to commit. To check for this, you should test the result of commitTransaction - this will return a Boolean to indicate whether the transaction succeeded \(true\) or failed \(false\). Note that when a transaction fails to commit you have not lost the changes made during that failed transaction - the transaction is still active, the changed objects retain their changed state in memory and your changes still exist in the transaction. However none of the changes have been committed to the database - an update clash on one single object prevents the whole transaction from committing. #### Rollback and RefreshThe simplest action to take is to fail the whole transaction, rollback the changes made and update the clashing object\(s\) with the latest versions from the database. This is done as follows:```ReStore rollbackAndRefreshTransaction```Following `rollbackAndRefreshTransaction`, you could \(for example\) issue a notification of the clash to the user \(Another user has changed the data you were editing...\), present them with the refreshed objects and ask them to repeat their actions. #### Refresh and RollforwardAn alternative approach is to merge the changes in the transaction with the changes in the database. This is done as follows:```ReStore refreshAndRollforwardTransaction ```With `refreshAndRollforwardTransaction` the object\(s\) causing the update clash are refreshed with their latest versions from the database and the changes made in the transaction are re-applied onto the refreshed objects. Following a `refreshAndRollforwardTransaction`, you will need to send `commitTransaction` again, remembering that this second commit may also fail if any objects have been changed further since the refresh.Using `refreshAndRollforwardTransaction` avoids the user having to repeat their changes, but you should bear in mind that this also allows the user to overwrite another user's changes without having first viewed them.### Handling Store FailuresJust like when using transactions, a database update made via `store` or `storeAll` may also fail due to an update clash. In this case the `store[All]` message will answer false \(and conversely true in the event of a successful database update\). Unlike when using transactions, following a store failure there is no active transaction left open. However the object’s changes still exist in the image and so you need to decide how to proceed.#### Object RefreshIf you wish to bring the changed object\(s\) up-to-date with its current state in the database you can send the messages `refresh` and `refreshAll`- `changedObject refresh`- `changedObjects refreshAll`As noted in 4.2, `refresh[All]` effectively performs a rollback for objects that have not been updated in the database compared to your image. Thus it is equivalent to `rollbackAndRefreshTransaction` when working with transactions.#### Handling Store Failure with TransactionsThere is an alternative method of handling `store[All]` failures that enables you to catch a failure while the transaction is still active. To do this you should trap the exception `StoreFailure` when attempting the store operation; you may then directly interact with the failed transaction \(the exception parameter providing a wrapper onto this\). Example:```[object store] on: StoreFailure do: [ :transaction | transaction rollbackAndRefresh]```See the operations method category of `StoreFailure` for other supported actions. ### Minimizing Update ClashesReStore will attempt to minimize update clashes by handling them automatically wherever possible. When a clash is detected, ReStore will compare three versions of the object: - the object as it was prior to the current change \(version 1\)- the object as it is in memory, following the change \(version 2\)- the object as it is currently stored in the database \(version 3\) If the changes made in the database \(`1>>3`\) are independent of the changes made in memory \(`1>>2`\) ReStore will avoid an update clash by refreshing 2 with the changes made between 1 and 3. It will then commit this merged version of the object, giving version 4. For example: | Time | User A | User B | Database |  || 00:00 | Begin editing Person 'John Smith' |  | 'John Smith' |  || 00:01 |  | Begin editing Person 'John Smith' | 'John Smith' |  || 00:09 | Change surname to '**Smythe**' |  | 'John Smith' |  || 00:10 |  | Change firstName to '**James**"' 	'John Smith' |  || 00:14 | Commit Transaction |  | 'John **Smythe** |  || 00:15 |  | Commit Transaction **fails; update clash detected** | 'John Smythe' |  || 00:16 |  | Merge changes, recommit **succeeds** | '**James** Smythe' |  |If this automatic merging is not acceptable for a particular object \(or particular instance variables of an object\) you can override the method `mergeUpdate:from:` to prevent this by returning false - see the comment of the `Object` implementation of this method for further information.### Handling Clashes AutomaticallyIf there is a 'full' update clash \(i.e. the changes 1>>2 and 1>>3 affect one or more of the same instance variables\) ReStore will ask the changed object itself to try to resolve the change. ReStore does this by sending the message handleUpdateClash:from:to: to the affected object\(s\) for each clashing instance variable − the arguments to the message being the changed instance variable \(a Symbol\), the previous version of the object \(version 1\) and the current database version of the object \(version 3\).By implementing `handleUpdateClash:from:to:` in your model classes you can update the receiver \(i.e. version 2, the in-memory version of the object\) to resolve the clash. The result of this method should be a Boolean indicating whether the clash was resolved. If all update-clashing objects in a transaction are able to resolve their own clashes, then the transaction will automatically re-commit successfully with no further intervention.As an example we’ll return to the previous `CustomerOrder` example, in particular the `Product` class. The most volatile attribute of a `Product` is likely to be its `stockLevel` since this will change every time an order is made for that item. A popular item is likely to be ordered by many users at one time, and so an update clash on stockLevel is highly likely. Product can attempt to resolve stockLevel update clashes by implementing `handleUpdateClash:from:to:````handleUpdateClash: aSymbol from: oldVersion to: newVersion

	| myStockChange mergedStockLevel |
	(aSymbol = #numberInStock) ifFalse: [^false].
	myStockChange := self stockLevel – oldVersion stockLevel.
	mergedStockLevel := newVersion stockLevel + myStockChange.

	^mergedStockLevel >= 0
		ifTrue: [self stockLevel: newStockLevel. true]
		ifFalse: [false] ```	Firstly, the method checks whether the clashing attribute \(aSymbol\) is actually `stockLevel`; if not it makes no further attempt to handle the clash.Next, the relative change in stockLevel between version1 \(`oldVersion`\) and version 2 \(`self`\) is calculated. The method then applies this change of stock level to the stockLevel as currently stored in the database \(`newVersion`\), to give the new, merged, stock level.Finally the method checks that the merged stock level change is not negative - this would be invalid and so cannot be handled. Assuming this is not the case, however, the merged `stockLevel` is applied to the receiver and true is returned to denote that the update clash has been handled successfully.By targeting implementations of `handleUpdateClash:from:to:` at situations where update clashes are likely, you can improve the usability of your applications by ensuring that most transactions commit successfully on the first attempt.