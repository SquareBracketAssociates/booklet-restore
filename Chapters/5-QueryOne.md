## Query IntroductionOnce you have started storing objects, you need some way to find and bring them back into your image. ReStore provides a sophisticated querying mechanism based around the semantics of standard Smalltalk collection enumeration methods \(`select:`, `detect:`, etc.\).#### Stored InstancesIf you want to obtain all in-memory instances of a class in your image, you send the message allInstances to that class. ReStore provides a similar message - **storedInstances** - that answers a collection-like object representing all instances of a class that exist in the database. Note this is a not a real collection – no objects are fetched from the database by sending `storedInstances`. Instead this virtual collection is a starting point for actual querying using enumeration methods \(`select:`, `detect:`, etc.\) in almost exactly the same manner as a regular collection. The block arguments to the enumeration methods are not executed in the image but translated to SQL and run directly in the database, transferring computation to the database server and so minimizing the amount of data transferred.Thus querying your database is efficient \(no objects are actually fetched from the database until actually required\) and as simple as using regular Smalltalk collection methods. In addition you can use much of the same code for both real Smalltalk collections and virtual, database-resident collections.#### Object IdentityOnce you have a persistent object in memory then you may traverse its references to other persistent objects exactly as you would with a regular non-persistent object. These linked objects are automatically and transparently fetched from the database the first time they are sent a message. Note that ReStore will always maintain the **identity** of objects returned from the database − that is, if you have a persistent object in memory, and that object is also included in the results of a subsequent query, or is referenced from another persistent object, then the existing in−memory object will be used. This also means that cyclical structures − Object A references Object B references Object A − are not a problem.   ### Enumerating Stored InstancesThe following enumeration methods work in the same way as their Collection counterparts:- `select:`- `reject:`- `detect:`- `detect:ifNone:`- `collect:`- `select:thenCollect:`- `allSatisfy:`- `anySatisfy:`Examples:```"Obtain a virtual collection representing all Customers in the database"
allCustomers := Customer storedInstances. 

"Retrieve all Customers with the surname Smith"
allCustomers select: [ :each | each surname = 'Smith'].
 
"Find Customer number 12345"
allCustomers detect: [ :each | each customerNo = 12345].
 
"Do we have any Customers in London?"
allCustomers anySatisfy: [ :each | each address city = 'London'].

"Who has placed an order today?"
allCustomers select: [ :each | each customerOrders anySatisfy: [ :order | order date = Date today]]. ```To re-emphasize, no objects are actually fetched from the database until actually required. Only the second, third and last examples above will actually fetch objects from the database, and then only the ones matching the query block. This ensures that the absolute minimum of data is transferred from the database, making querying quick and efficient. ### Enumeration Blocks The blocks passed to enumeration methods \(`select:` etc.\) are not actually evaluated with each object in the database; instead the block is analyzed by ReStore and converted into an equivalent SQL query. This means there are certain limitations on the messages that can be sent within the block.#### Instance Variable Accessors – Single ObjectsAny instance variable of the class holding a single \(non-collection\) object may be used via its equivalently-named accessor message. Where the instance variable holds another persistent object then that object’s instance variable accessors may then be used \(recursively\). The following previous examples demonstrate this:```allCustomers select: [ :each | each surname = 'Smith'].
allCustomers detect: [ :each | each customerNo = 12345].
allCustomers anySatisfy: [ :each | each address city = 'London'].```#### Instance Variable Accessors – Collection ObjectsAny instance variable of the class holding a collection object may also be used via its equivalently-named accessor message. Subsequent messages should make sense to a collection; examples:```allCustomers reject: [ :each | each customerOrders isEmpty].
allCustomers select: [ :each | each customerOrders size > 10].
allCustomers select: [ :each | each customerOrders anySatisfy: [ :order | order date = Date today]]. ```#### Other Local MethodsIn addition to a class’s accessor methods you may also refer to other methods defined by the class which themselves obey the same rules as query blocks. For example, if `Customer` defines the following method:```fullName 

	^self firstName, ' ', self surname```…then the following is a valid enumeration block:```allCustomers select: [ :each | each fullName = 'John Smith'].``` #### Condition MessagesThe following condition messages may be used:- `=`, `~=`- `<`,`<=`, `>`, `>=`- `between:and:`- `isNil`, `notNil`- `isEmpty`- `match:` - `includes:` #### Logical OperatorsConditions may be combined using the logical operators AND and OR, for example:```"Do we have any Smiths in London?"
allCustomers anySatisfy: [ :each | each surname = 'Smith' and: [each address city = 'London']] ```#### Messages and FunctionsWhen dealing with a basic object \(`String`, `Number`, `Date`, etc.\) within an enumeration block it is possible to send certain standard Smalltalk messages to these objects – these are translated into SQL functions that are then executed by the database. Translating messages to functions in this way transfers work from the Smalltalk image to the database, reducing the amount of data transferred and making querying more efficient. The actual messages supported vary from database to database depending on the functions supported but commonly include the following: String messages- ,- `size`- `asUppercase`- `asLowercase`- `trimBlanks`Numeric messages- Mathematical operators \(`+`,`-`, `*`, `/`, `\\` etc.\)- `asInteger`- `abs`See definitions of commonFunctions and dialectSpecificFunctions in the `SSWSQLDialect` hierarchy for further examples. You may also add your own function translations \(see section 6.6\).### SortingAs with a standard SortedCollection it is possible to define a sort order for a storedInstances collection via the use of a sort block - a two-argument block defining the relative ordering of two instances. A sort block is defined on a storedInstances collection by sending the message sortBlock: - once defined, all database activity against that collection will be ordered by use of equivalent SQL ORDER directives. For example, the following sort block:```	[ :p1 :p2 | p1 surname <= p2 surname]```… translates to the following SQL```	ORDER BY SURNAME ASC```#### Limitations on Sort BlocksAs with enumeration blocks, sort blocks used within ReStore are subject to certain limitations. Firstly, the sorting must be defined only in terms of the instance variables of the class of object held by the collection. Secondly, the sort block must be defined logically, not procedurally. This is not normally a concern where the sorting is defined on a single attribute \(as with the surname example above\) but is important where more than one attribute is used. As an example, consider the following way of defining a sort order on \(firstly\) the surname of a Customer object, and then \(if surnames are equal\) on the firstName:```	[ :p1 :p2 | 
	(p1 surname = p2 surname)
		ifTrue: [p1 firstName <= p2 firstName]
		ifFalse: [p1 surname < p2 surname]]```	This is a procedural definition, in that a flow of program control is defined - firstly an = test is applied, then, depending on the result, either a firstName or surname comparison. Such a sort block is not suitable for use with an storedInstances collection - it should be redefined logically as follows:```	[ :p1 :p2 | 
	(p1 surname < p2 surname) | 
		((p1 surname = p2 surname) & (p1 firstName <= p2 firstName))]```In this implementation, the comparison is defined purely in terms of `<`, `=` , `&` \(logical AND\) and | \(logical OR\). ReStore is able to translate such a sort block into the equivalent SQL order directives.Note these limitations also apply to the use of `SortedCollections` in a class definition \(see 2.4\) and to the implementation of `<=` in a persistent class where such an implementation is used to define the sort order.  ### Other Collection Messages In addition to enumeration messages certain other standard Collection messages may be sent to a storedInstances virtual collection.**asOrderedCollection** By sending `asOrderedCollection` you can convert an `storedInstances` collection into a regular `OrderedCollection`. An advantage of this is that the limitations on enumeration blocks no longer apply − you are now dealing with a real Smalltalk collection. Implicit in this is that all objects forming the collection are fetched from the database into your Smalltalk image; if this is a large number then asOrderedCollection may take a while to execute. Together with the overhead of allocating the memory for a significant number of objects, asOrderedCollection should be used with care. **asSortedCollection**Similar to `asOrderedCollection`, `asSortedCollection` and `asSortedCollection:` can convert a `storedInstances` collection into a regular `SortedCollection`. If the storedInstances collection already has a sort defined \(via `sortBlock:`\), then asSortedCollection will use that sort block, otherwise the default sort for the class of object in the collection will be used \(i.e. its implementation of `<=`\). `asSortedCollection:`, like the standard Smalltalk implementation, takes the sort block to use as its parameter.As with `sortBlock:`, the sort block or implementation of `<=` must conform to the rules for use with ReStore \(see 5.3\).**size**As with a standard collection size will return the number of elements of an storedInstances collection. However, rather than fetching the entire collection from the database this is done by issuing a 'count' query whose sole result is the size of the collection, thus the overhead is minimal. It can be a good idea to use `size` before `asOrderedCollection` to check that the collection to be fetched is not unreasonably large. **isEmpty**`isEmpty` is provided for convenience. This simply uses size to test for a zero-element collection, and hence has the same performance benefits. **first, last**These messages will fetch just the first or last object in the `storedInstances` collection without needing to fetch all members of the collection. You may also use the related parameterized `first:` and `last:` messages to fetch the first or last “N” elements. Like a regular collection, these messages will raise an error if the collection has no members.  ### Query by Example    ReStore also supports an alternative way of querying which can be used in addition to the enumeration-based methods discussed so far. This is termed **Query by Example**.Querying by example is accomplished by creating a template object which is 'similar to' the instance\(s\) you wish to find in the database. By 'similar to', we mean that the template object has certain of its instance variables filled, and 'similar' instances will have the same instance variables filled with the same values.Once a template object has been created, sending it the message similarInstances will result in a `storedInstances` collection of matching objects from the database. This collection can then be used in the same ways discussed earlier \(e.g. `asOrderedCollection` to return an actual Smalltalk collection, satisfying: to further refine etc.\). Example:```template := Customer new.
template surname: 'Smith'.
allSmiths := template similarInstances.

template address city: 'London'.
allSmithsInLondon := template similarInstances.```Query by example is particularly useful when developing a 'Find'-type user interface. The model of the screen would be the template object; as the user fills in the details to be found, the template object is also filled in. When the user hits 'Find', it is only necessary to send `similarInstances` to the template object to find the required instances.#### WildcardsOne potential disadvantage with the use of template objects is that they require a 'hard' match - e.g. in the above example someone named 'Smithe' would not be included in the resulting collection. In a block-based query, it is possible to use the match: message to look for a partial match such as this \(e.g. 'Smith*' match: surname\). To check for such partial matches when querying by example, it is necessary to send the message `asWildcard` to the `String` denoting a partial match:```template := Customer new.
template surname: 'Smith*' asWildcard.
allSmithsEtc := template similarInstances.``` #### Requiring nilQuery by example relies on only the aspects of interest being set in the template object - any attribute which is unset will be nil, and is thus ignored when determining the similar instances.Occasionally it can be useful for an unset attribute to be a requirement of the similar objects. For example, to determine any unsent CustomerOrder objects it may be necessary to check for instances with a `despatchDate` of `nil`. Such a requirement can be expressed by sending the message `required` to nil:```template := CustomerOrder new.
template despatchDate: nil required.
allUnsentOrders := template similarInstances.``` 